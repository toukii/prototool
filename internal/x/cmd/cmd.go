// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package cmd

import (
	"fmt"
	"io"
	"os"
	"runtime"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
	"github.com/spf13/pflag"
	"github.com/tgrpc/prototool/internal/x/exec"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

// when generating man pages, the current date is used
// this means every time we run make gen, a diff is created
// this gets extremely annoying and isn't very useful so we make it static here
// we could also not check in the man pages, but for now we have them checked in
var genManTime = time.Date(2018, time.January, 1, 0, 0, 0, 0, time.UTC)

// Do runs the command logic.
func Do(args []string, stdin io.Reader, stdout io.Writer, stderr io.Writer) int {
	return runRootCommand(args, stdin, stdout, stderr, (*cobra.Command).Execute)
}

// GenBashCompletion generates a bash completion file to the writer.
func GenBashCompletion(stdin io.Reader, stdout io.Writer, stderr io.Writer) int {
	return runRootCommandOutput([]string{}, stdin, stdout, stderr, (*cobra.Command).GenBashCompletion)
}

// GenZshCompletion generates a zsh completion file to the writer.
func GenZshCompletion(stdin io.Reader, stdout io.Writer, stderr io.Writer) int {
	return runRootCommandOutput([]string{}, stdin, stdout, stderr, (*cobra.Command).GenZshCompletion)
}

// GenManpages generates the manpages to the given directory.
func GenManpages(args []string, stdin io.Reader, stdout io.Writer, stderr io.Writer) int {
	return runRootCommand(args, stdin, stdout, stderr, func(cmd *cobra.Command) error {
		if len(args) != 1 {
			return fmt.Errorf("usage: %s dirPath", os.Args[0])
		}
		return doc.GenManTree(cmd, &doc.GenManHeader{
			Date: &genManTime,
			// Otherwise we get an annoying "Auto generated by spf13/cobra"
			// Maybe we want that, but I think it's better to just have this
			Source: "Prototool",
		}, args[0])
	})
}

func runRootCommandOutput(args []string, stdin io.Reader, stdout io.Writer, stderr io.Writer, f func(*cobra.Command, io.Writer) error) int {
	return runRootCommand(args, stdin, stdout, stderr, func(cmd *cobra.Command) error { return f(cmd, stdout) })
}

func runRootCommand(args []string, stdin io.Reader, stdout io.Writer, stderr io.Writer, f func(*cobra.Command) error) (exitCode int) {
	if err := checkOS(); err != nil {
		return printAndGetErrorExitCode(err, stdout)
	}
	if err := f(getRootCommand(&exitCode, args, stdin, stdout, stderr)); err != nil {
		return printAndGetErrorExitCode(err, stdout)
	}
	return exitCode
}

func getRootCommand(exitCodeAddr *int, args []string, stdin io.Reader, stdout io.Writer, stderr io.Writer) *cobra.Command {
	flags := &flags{}

	versionCmd := &cobra.Command{
		Use:   "version",
		Short: "Print the version.",
		Args:  cobra.NoArgs,
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, exec.Runner.Version)
		},
	}

	initCmd := &cobra.Command{
		Use:   "init [dirPath]",
		Short: "Generate an initial config file in the current or given directory.",
		Args:  cobra.MaximumNArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.Init(args, flags.uncomment) })
		},
	}
	flags.bindUncomment(initCmd.PersistentFlags())

	downloadCmd := &cobra.Command{
		Use:   "download",
		Short: "Download the protobuf artifacts to a cache.",
		Args:  cobra.NoArgs,
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, exec.Runner.Download)
		},
	}

	cleanCmd := &cobra.Command{
		Use:   "clean",
		Short: "Delete the cache.",
		Args:  cobra.NoArgs,
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, exec.Runner.Clean)
		},
	}

	filesCmd := &cobra.Command{
		Use:   "files dirOrProtoFiles...",
		Short: "Print all files that match the input arguments.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.Files(args) })
		},
	}

	compileCmd := &cobra.Command{
		Use:   "compile dirOrProtoFiles...",
		Short: "Compile with protoc to check for failures.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.Compile(args) })
		},
	}
	flags.bindDirMode(compileCmd.PersistentFlags())

	genCmd := &cobra.Command{
		Use:   "gen dirOrProtoFiles...",
		Short: "Generate with protoc.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.Gen(args) })
		},
	}
	flags.bindDirMode(genCmd.PersistentFlags())

	descriptorProtoCmd := &cobra.Command{
		Use:   "descriptor-proto dirOrProtoFiles... messagePath",
		Short: "Get the descriptor proto for the message path.",
		Args:  cobra.MinimumNArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.DescriptorProto(args) })
		},
	}
	flags.bindDirMode(descriptorProtoCmd.PersistentFlags())

	fieldDescriptorProtoCmd := &cobra.Command{
		Use:   "field-descriptor-proto dirOrProtoFiles... fieldPath",
		Short: "Get the field descriptor proto for the field path.",
		Args:  cobra.MinimumNArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.FieldDescriptorProto(args) })
		},
	}
	flags.bindDirMode(fieldDescriptorProtoCmd.PersistentFlags())

	serviceDescriptorProtoCmd := &cobra.Command{
		Use:   "service-descriptor-proto dirOrProtoFiles... servicePath",
		Short: "Get the service descriptor proto for the service path.",
		Args:  cobra.MinimumNArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.ServiceDescriptorProto(args) })
		},
	}
	flags.bindDirMode(serviceDescriptorProtoCmd.PersistentFlags())

	protocCommandsCmd := &cobra.Command{
		Use:   "protoc-commands dirOrProtoFiles...",
		Short: "Print the commands that would be run on compile or gen.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.ProtocCommands(args, flags.gen) })
		},
	}
	flags.bindGen(protocCommandsCmd.PersistentFlags())
	flags.bindDirMode(protocCommandsCmd.PersistentFlags())

	lintCmd := &cobra.Command{
		Use:   "lint dirOrProtoFiles...",
		Short: "Lint proto files and compile with protoc to check for failures.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.Lint(args) })
		},
	}
	flags.bindDirMode(lintCmd.PersistentFlags())

	listLintersCmd := &cobra.Command{
		Use:   "list-linters",
		Short: "List the configurerd linters.",
		Args:  cobra.NoArgs,
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, exec.Runner.ListLinters)
		},
	}

	listAllLintersCmd := &cobra.Command{
		Use:   "list-all-linters",
		Short: "List all available linters.",
		Args:  cobra.NoArgs,
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, exec.Runner.ListAllLinters)
		},
	}

	listLintGroupCmd := &cobra.Command{
		Use:   "list-lint-group group",
		Short: "List the linters in the given lint group.",
		Args:  cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.ListLintGroup(args[0]) })
		},
	}

	listAllLintGroupsCmd := &cobra.Command{
		Use:   "list-all-lint-groups",
		Short: "List all the available lint groups.",
		Args:  cobra.NoArgs,
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, exec.Runner.ListAllLintGroups)
		},
	}

	formatCmd := &cobra.Command{
		Use:   "format dirOrProtoFiles...",
		Short: "Format a proto file and compile with protoc to check for failures.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error {
				return runner.Format(args, flags.overwrite, flags.diffMode, flags.lintMode)
			})
		},
	}
	flags.bindOverwrite(formatCmd.PersistentFlags())
	flags.bindDiffMode(formatCmd.PersistentFlags())
	flags.bindLintMode(formatCmd.PersistentFlags())

	binaryToJSONCmd := &cobra.Command{
		Use:   "binary-to-json dirOrProtoFiles... messagePath data",
		Short: "Convert the data from json to binary for the message path and data.",
		Args:  cobra.MinimumNArgs(3),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.BinaryToJSON(args) })
		},
	}
	flags.bindDirMode(binaryToJSONCmd.PersistentFlags())

	jsonToBinaryCmd := &cobra.Command{
		Use:   "json-to-binary dirOrProtoFiles... messagePath data",
		Short: "Convert the data from json to binary for the message path and data.",
		Args:  cobra.MinimumNArgs(2),
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error { return runner.JSONToBinary(args) })
		},
	}
	flags.bindDirMode(jsonToBinaryCmd.PersistentFlags())

	allCmd := &cobra.Command{
		Use:   "all dirOrProtoFiles...",
		Short: "Compile, then format and overwrite, then re-compile and generate, then lint, stopping if any step fails.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error {
				return runner.All(args, flags.disableFormat, flags.disableLint)
			})
		},
	}
	flags.bindDisableFormat(allCmd.PersistentFlags())
	flags.bindDisableLint(allCmd.PersistentFlags())
	flags.bindDirMode(allCmd.PersistentFlags())

	grpcCmd := &cobra.Command{
		Use:   "grpc dirOrProtoFiles... serverAddress package.service/Method requestData",
		Short: "Call a gRPC endpoint.",
		Run: func(cmd *cobra.Command, args []string) {
			checkCmd(exitCodeAddr, stdin, stdout, stderr, flags, func(runner exec.Runner) error {
				return runner.GRPC(args, flags.headers, flags.callTimeout, flags.connectTimeout, flags.keepaliveTime)
			})
		},
	}
	flags.bindHeaders(grpcCmd.PersistentFlags())
	flags.bindCallTimeout(grpcCmd.PersistentFlags())
	flags.bindConnectTimeout(grpcCmd.PersistentFlags())
	flags.bindKeepaliveTime(grpcCmd.PersistentFlags())
	flags.bindDirMode(grpcCmd.PersistentFlags())

	rootCmd := &cobra.Command{Use: "prototool"}
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(initCmd)
	rootCmd.AddCommand(downloadCmd)
	rootCmd.AddCommand(cleanCmd)
	rootCmd.AddCommand(filesCmd)
	rootCmd.AddCommand(compileCmd)
	rootCmd.AddCommand(genCmd)
	rootCmd.AddCommand(descriptorProtoCmd)
	rootCmd.AddCommand(fieldDescriptorProtoCmd)
	rootCmd.AddCommand(serviceDescriptorProtoCmd)
	rootCmd.AddCommand(protocCommandsCmd)
	rootCmd.AddCommand(lintCmd)
	rootCmd.AddCommand(listLintersCmd)
	rootCmd.AddCommand(listAllLintersCmd)
	rootCmd.AddCommand(listLintGroupCmd)
	rootCmd.AddCommand(listAllLintGroupsCmd)
	rootCmd.AddCommand(formatCmd)
	rootCmd.AddCommand(binaryToJSONCmd)
	rootCmd.AddCommand(jsonToBinaryCmd)
	rootCmd.AddCommand(allCmd)
	rootCmd.AddCommand(grpcCmd)

	flags.bindDebug(rootCmd.PersistentFlags())
	flags.bindCachePath(rootCmd.PersistentFlags())
	flags.bindProtocURL(rootCmd.PersistentFlags())
	flags.bindPrintFields(rootCmd.PersistentFlags())

	rootCmd.SetArgs(args)
	rootCmd.SetOutput(stdout)

	return rootCmd
}

func checkOS() error {
	switch runtime.GOOS {
	case "darwin", "linux":
		return nil
	default:
		return fmt.Errorf("%s is not a supported operating system, if you want to go through the code and change all the strings.HasPrefix and \"/\" stuff to os.PathSeparator and filepath calls, you're more than welcome to", runtime.GOOS)
	}
}

func checkCmd(exitCodeAddr *int, stdin io.Reader, stdout io.Writer, stderr io.Writer, flags *flags, f func(exec.Runner) error) {
	runner, err := getRunner(stdin, stdout, stderr, flags)
	if err != nil {
		*exitCodeAddr = printAndGetErrorExitCode(err, stdout)
		return
	}
	if err := f(runner); err != nil {
		*exitCodeAddr = printAndGetErrorExitCode(err, stdout)
	}
}

func getRunner(stdin io.Reader, stdout io.Writer, stderr io.Writer, flags *flags) (exec.Runner, error) {
	logger, err := getLogger(stderr, flags.debug)
	if err != nil {
		return nil, err
	}
	runnerOptions := []exec.RunnerOption{
		exec.RunnerWithLogger(logger),
	}
	if flags.cachePath != "" {
		runnerOptions = append(
			runnerOptions,
			exec.RunnerWithCachePath(flags.cachePath),
		)
	}
	if flags.protocURL != "" {
		runnerOptions = append(
			runnerOptions,
			exec.RunnerWithProtocURL(flags.protocURL),
		)
	}
	if flags.printFields != "" {
		runnerOptions = append(
			runnerOptions,
			exec.RunnerWithPrintFields(flags.printFields),
		)
	}
	if flags.dirMode {
		runnerOptions = append(
			runnerOptions,
			exec.RunnerWithDirMode(),
		)
	}
	workDirPath, err := os.Getwd()
	if err != nil {
		return nil, err
	}
	return exec.NewRunner(workDirPath, stdin, stdout, runnerOptions...), nil
}

func getLogger(stderr io.Writer, debug bool) (*zap.Logger, error) {
	level := zapcore.InfoLevel
	if debug {
		level = zapcore.DebugLevel
	}
	return zap.New(
		zapcore.NewCore(
			zapcore.NewConsoleEncoder(
				zap.NewDevelopmentEncoderConfig(),
			),
			zapcore.Lock(zapcore.AddSync(stderr)),
			zap.NewAtomicLevelAt(level),
		),
	), nil
}

func printAndGetErrorExitCode(err error, stdout io.Writer) int {
	if errString := err.Error(); errString != "" {
		fmt.Fprintln(stdout, errString)
	}
	if exitError, ok := err.(*exec.ExitError); ok {
		return exitError.Code
	}
	return 1
}

type flags struct {
	debug          bool
	cachePath      string
	protocURL      string
	printFields    string
	dirMode        bool
	overwrite      bool
	diffMode       bool
	lintMode       bool
	disableFormat  bool
	disableLint    bool
	gen            bool
	headers        []string
	callTimeout    string
	connectTimeout string
	keepaliveTime  string
	uncomment      bool
}

func (f *flags) bindDebug(flagSet *pflag.FlagSet) {
	flagSet.BoolVar(&f.debug, "debug", false, "Run in debug mode, which will print out debug logging.")
}

func (f *flags) bindCachePath(flagSet *pflag.FlagSet) {
	flagSet.StringVar(&f.cachePath, "cache-path", "", "The path to use for the cache, otherwise uses the default behavior.")
}

func (f *flags) bindProtocURL(flagSet *pflag.FlagSet) {
	flagSet.StringVar(&f.protocURL, "protoc-url", "", "The url to use to download the protoc zip file, otherwise uses GitHub Releases. Setting this option will ignore the config protoc_version setting.")
}

func (f *flags) bindPrintFields(flagSet *pflag.FlagSet) {
	flagSet.StringVar(&f.printFields, "print-fields", "filename:line:column:message", "The colon-separated fields to print out on error.")
}

func (f *flags) bindDirMode(flagSet *pflag.FlagSet) {
	flagSet.BoolVar(&f.dirMode, "dir-mode", false, "Run as if the directory the file was given, but only print the errors from the file. Useful for integration with editors.")
}

func (f *flags) bindOverwrite(flagSet *pflag.FlagSet) {
	flagSet.BoolVarP(&f.overwrite, "overwrite", "w", false, "Overwrite the existing file instead of writing the formatted file to stdout.")
}

func (f *flags) bindDiffMode(flagSet *pflag.FlagSet) {
	flagSet.BoolVarP(&f.diffMode, "diff", "d", false, "Write a diff instead of writing the formatted file to stdout.")
}

func (f *flags) bindLintMode(flagSet *pflag.FlagSet) {
	flagSet.BoolVarP(&f.lintMode, "lint", "l", false, "Write a lint error saying that the file is not formatted instead of writing the formatted file to stdout.")
}

func (f *flags) bindDisableFormat(flagSet *pflag.FlagSet) {
	flagSet.BoolVar(&f.disableFormat, "disable-format", false, "Do not run formatting.")
}

func (f *flags) bindDisableLint(flagSet *pflag.FlagSet) {
	flagSet.BoolVar(&f.disableLint, "disable-lint", false, "Do not run linting.")
}

func (f *flags) bindGen(flagSet *pflag.FlagSet) {
	flagSet.BoolVar(&f.gen, "gen", false, "Print the commands that would be run on gen instead of compile.")
}

func (f *flags) bindHeaders(flagSet *pflag.FlagSet) {
	flagSet.StringSliceVarP(&f.headers, "header", "H", []string{}, "Additional request headers in 'name:value' format.")
	for _, h := range f.headers {
		fmt.Println(h)
	}
}

func (f *flags) bindCallTimeout(flagSet *pflag.FlagSet) {
	flagSet.StringVar(&f.callTimeout, "call-timeout", "60s", "The maximum time to for all calls to be completed.")
}

func (f *flags) bindConnectTimeout(flagSet *pflag.FlagSet) {
	flagSet.StringVar(&f.connectTimeout, "connect-timeout", "10s", "The maximum time to wait for the connection to be established.")
}

func (f *flags) bindKeepaliveTime(flagSet *pflag.FlagSet) {
	flagSet.StringVar(&f.keepaliveTime, "keepalive-time", "", "The maximum idle time after which a keepalive probe is sent.")
}

func (f *flags) bindUncomment(flagSet *pflag.FlagSet) {
	flagSet.BoolVar(&f.uncomment, "uncomment", false, "Uncomment the example config settings.")
}
